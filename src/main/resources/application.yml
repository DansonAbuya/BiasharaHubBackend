spring:
  application:
    name: biasharahub-backend

  # Not used for sending: 2FA and transactional email use REST only (Postmark or Gmail API).
  mail:
    host: ${MAIL_HOST:localhost}
    port: ${MAIL_PORT:1025}
    username: ${MAIL_USERNAME:}
    password: ${MAIL_PASSWORD:}
    properties:
      mail:
        smtp:
          auth: ${MAIL_SMTP_AUTH:false}
          starttls:
            enable: ${MAIL_SMTP_STARTTLS_ENABLE:false}

  datasource:
    # Default schema is set server-side (see db/scripts/set-default-schema.sql). Do not set currentSchema in URL.
    url: jdbc:postgresql://localhost:5432/biasharahub
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:password}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        # Use tenant_default at startup (Liquibase creates it); per-request schema is set by TenantFilter
        default_schema: ${tenant.schema:tenant_default}
        format_sql: true
    open-in-view: false

  liquibase:
    change-log: classpath:db/changelog/db.changelog-master.xml
    # Use public schema explicitly so Liquibase works even if server-side set-default-schema.sql was not run
    liquibase-schema: public
    default-schema: public

  cache:
    # Use Redis as backing store for Spring Cache (requires running Redis instance)
    type: redis
    redis:
      # 5 minutes default TTL for cache entries
      time-to-live: 300000

  servlet:
    multipart:
      max-file-size: 20MB
      max-request-size: 20MB

  # OAuth2 Client (Google for 2FA). Add registration in application-local.yml or set GOOGLE_CLIENT_ID/GOOGLE_CLIENT_SECRET.
  # When no registration is defined, app starts with email-only 2FA; OAuth2 2FA endpoints return 503.
  security:
    oauth2:
      client:
        registration: {}
  # Redis connection for cache and other features
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      repositories:
        # We only use Redis as a cache backend, not as a Spring Data store
        enabled: false

  # Kafka (used only when app.kafka.enabled=true; see KafkaConfig)
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: ${KAFKA_CONSUMER_GROUP:biasharahub}
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: com.biasharahub.messaging
    listener:
      missing-topics-fatal: false

server:
  port: ${SERVER_PORT:5050}
  servlet:
    context-path: /api
  # Use HTTP only (no SSL) for local dev so you can access via http://localhost
  ssl:
    enabled: false

# JWT Configuration
jwt:
  secret: ${JWT_SECRET:biasharahub-super-secret-key-min-256-bits-required-for-hs256}
  expiration-ms: 3600000   # 1 hour (access token)
  refresh-expiration-ms: 604800000  # 7 days (refresh token)

# OAuth2 2FA
app:
  frontend-url: ${APP_FRONTEND_URL:http://localhost:3000}
  oauth2:
    backend-base-url: ${OAUTH2_BACKEND_BASE_URL:http://localhost:5050/api}
    frontend-redirect-uri: ${OAUTH2_FRONTEND_REDIRECT_URI:http://localhost:3000/auth/callback}
  mail:
    from: ${MAIL_FROM:}
    # Postmark (recommended): set POSTMARK_SERVER_TOKEN and MAIL_FROM (and optionally POSTMARK_MESSAGE_STREAM)
    postmark:
      server-token: ${POSTMARK_SERVER_TOKEN:}
      from: ${MAIL_FROM:}
      message-stream: ${POSTMARK_MESSAGE_STREAM:outbound}
    # Gmail OAuth: set GMAIL_CLIENT_ID, GMAIL_CLIENT_SECRET, GMAIL_REFRESH_TOKEN, MAIL_FROM
    # or use application-local.yml (gitignored). No defaults here to avoid committing secrets.
    gmail:
      client-id: ${GMAIL_CLIENT_ID:}
      client-secret: ${GMAIL_CLIENT_SECRET:}
      refresh-token: ${GMAIL_REFRESH_TOKEN:}
      from: ${MAIL_FROM:}
      refresh-interval-ms: 3000000   # 50 min (token ~1h expiry)

  # CORS (adjust for production)
  cors:
    allowed-origins: http://localhost:3000,http://127.0.0.1:3000databasechangeloglock

  # Kafka (event publishing for orders/payments). Set KAFKA_ENABLED=true and KAFKA_BOOTSTRAP_SERVERS to use.
  kafka:
    enabled: ${KAFKA_ENABLED:true}
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    topics:
      order-created: ${KAFKA_TOPIC_ORDER_CREATED:orders.created}
      payment-completed: ${KAFKA_TOPIC_PAYMENT_COMPLETED:payments.completed}

  # In-process async (no broker): run order/payment handlers in a background thread. Default true when not using Kafka.
  messaging:
    in-process:
      enabled: ${MESSAGING_IN_PROCESS_ENABLED:true}

  # Wallet / payouts
  wallet:
    # Platform commission share on incoming payments (0.1 = 10%)
    platform-commission-rate: ${PLATFORM_COMMISSION_RATE:0.1}
    # Minimum payout amount in KES (default 10)
    min-payout-kes: ${WALLET_MIN_PAYOUT_KES:10}

  # M-Pesa (Daraja) configuration for payments and payouts
  # All values (shortcode, passkey, consumer-key, consumer-secret) must come from your app at https://developer.safaricom.co.ke
  # "Merchant does not exist" (500.001.1001) = shortcode/credentials not valid for this app; use the ones from the Daraja portal.
  # Callback URLs must be HTTPS and publicly reachable; for local dev use a tunnel (e.g. ngrok http 5050).
  mpesa:
    enabled: ${MPESA_ENABLED:true}
    environment: ${MPESA_ENV:sandbox}          # sandbox or production
    base-url: ${MPESA_BASE_URL:https://sandbox.safaricom.co.ke}
    shortcode: ${MPESA_SHORTCODE:174379}       # use your sandbox Lipa Na M-Pesa Online shortcode from Daraja portal (often 174379)
    passkey: ${MPESA_PASSKEY:}                 # from Daraja app "Lipa Na M-Pesa Online" > Test credentials
    consumer-key: ${MPESA_CONSUMER_KEY:}       # from your Daraja app
    consumer-secret: ${MPESA_CONSUMER_SECRET:} # from your Daraja app
    # Set in application-local.yml or env. Example (use your ngrok or domain): https://abc123.ngrok-free.app/api/payments/mpesa/stk-callback
    stk-callback-url: ${MPESA_STK_CALLBACK_URL:}
    # Example: https://abc123.ngrok-free.app/api/payments/mpesa/b2c-callback
    b2c-callback-url: ${MPESA_B2C_CALLBACK_URL:}
    payout-product-name: ${MPESA_PAYOUT_PRODUCT_NAME:testapi}
    # B2C payouts: initiator name and security credential from M-Pesa B2C API user (portal)
    b2c-initiator-name: ${MPESA_B2C_INITIATOR_NAME:}
    b2c-security-credential: ${MPESA_B2C_SECURITY_CREDENTIAL:}
    b2c-shortcode: ${MPESA_B2C_SHORTCODE:${MPESA_SHORTCODE:174379}}
    timeout: ${MPESA_TIMEOUT_MS:10000}

  # WhatsApp via Twilio: order/payment/shipment notifications + incoming webhook for chatbot.
  # Use Twilio Sandbox (https://console.twilio.com/us1/develop/sms/try-it-out/whatsapp-learn) or a WhatsApp Business number.
  # Webhook: configure in Twilio Console "When a message comes in" â†’ set to: https://YOUR-PUBLIC-HOST/api/webhooks/whatsapp (must be HTTPS and publicly reachable; use ngrok for local).
  whatsapp:
    enabled: ${WHATSAPP_ENABLED:true}
    twilio-account-sid: ${TWILIO_ACCOUNT_SID:}
    twilio-auth-token: ${TWILIO_AUTH_TOKEN:}
    # Sender: Sandbox e.g. whatsapp:+14155238886, or your WhatsApp Business number (E.164 with whatsapp: prefix)
    from-number: ${TWILIO_WHATSAPP_FROM:whatsapp:+14155238886}
    # Optional: public base URL for webhook (for docs/setup). Twilio "When a message comes in" URL = this + /api/webhooks/whatsapp
    webhook-url: ${WHATSAPP_WEBHOOK_URL:}
  # Storefront URL for WhatsApp chatbot (order links, register link)
  storefront-url: ${STOREFRONT_URL:http://localhost:3000}

  # Courier provider API keys (never commit secrets; use env COURIER_<CODE>_API_KEY or app.courier.api-keys.<code>)
  courier:
    api-keys:
      dhl: ${COURIER_DHL_API_KEY:}
      fedex: ${COURIER_FEDEX_API_KEY:}
      sendy: ${COURIER_SENDY_API_KEY:}

  # (R2 for product/verification uploads is at top-level "r2:" so R2Config can bind it)


# Cloudflare R2 (S3-compatible) for product images and verification documents
# Must be top-level "r2:" for R2Config prefix to work.
r2:
  enabled: ${R2_ENABLED:true}
  bucket: ${R2_BUCKET:biasharahub-product-images}
  endpoint: ${R2_ENDPOINT:https://03c04814dd2c76d33ab9692b1255838c.r2.cloudflarestorage.com}
  access-key-id: ${R2_ACCESS_KEY_ID:}
  secret-access-key: ${R2_SECRET_ACCESS_KEY:}
  public-url: ${R2_PUBLIC_URL:}


# At-rest encryption for sensitive financial fields
encryption:
  secret: ${ENCRYPTION_SECRET:please-change-me-32-bytes-min}


# Swagger / OpenAPI (SpringDoc)
springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
